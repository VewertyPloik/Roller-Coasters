<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Roller Coasters</title>
<style>
body { margin:0; overflow:hidden; font-family:sans-serif; background:#87CEEB; }
canvas { display:block; }
#homeScreen, #endScreen {
  position:absolute; top:0; left:0; width:100vw; height:100vh;
  background:#87CEEB; display:flex; flex-direction:column;
  justify-content:center; align-items:center; z-index:10;
}
button {
  padding:12px 24px; font-size:20px; margin:10px; cursor:pointer;
  border:none; border-radius:10px; background:#0077ff; color:white;
}
#coasterButtons button {width:300px;}
#rideTime { font-size:24px; margin-bottom:20px; }
</style>
</head>
<body>

<div id="homeScreen">
  <div id="rideTime">Select a coaster to ride:</div>
  <div id="coasterButtons">
    <button id="coaster0">Rush - 47s</button>
    <button id="coaster1">Sky Whip - 2min 1s</button>
    <button id="coaster2">ZoomZoom - 2min 1s</button>
    <button id="coaster3">Speedy Spin - 2min 7s</button>
    <button id="coaster4">Death - 2min 14s</button>
  </div>
</div>

<div id="endScreen" style="display:none;">
  <button id="rideAgain">Ride Again</button>
  <button id="homeBtn">Home</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
class FontLoader { load(url, onLoad) { onLoad({ data:{} }); } }
class TextGeometry extends THREE.BufferGeometry { constructor(text, options){ super(); this.copy(new THREE.BoxGeometry(2,1,0.5)); } }

let scene, camera, renderer, curve, cart, endText;
let progress=0, riding=false, startTime=null;
let yaw=0, pitch=0;
let isDragging=false, previousX=0, previousY=0;

const coasters=[
  {name:"Rush", trackColor:"blue", supportColor:"darkblue", cartColor:"red", duration:35000, points:[
    new THREE.Vector3(0,5,0), new THREE.Vector3(15,15,-20), new THREE.Vector3(30,10,-40),
    new THREE.Vector3(40,15,-60), new THREE.Vector3(30,5,-80),
    new THREE.Vector3(0,10,-100), new THREE.Vector3(-15,15,-120),
    new THREE.Vector3(0,10,-140), new THREE.Vector3(0,10,-160)
  ]},
  {name:"Sky Whip", trackColor:"white", supportColor:"black", cartColor:"black", duration:60000, points:[
    new THREE.Vector3(0,5,0), new THREE.Vector3(30,30,-20), new THREE.Vector3(60,5,-50),
    new THREE.Vector3(20,40,-80), new THREE.Vector3(-20,10,-120),
    new THREE.Vector3(40,25,-150), new THREE.Vector3(-50,30,-180), new THREE.Vector3(0,15,-220),
    new THREE.Vector3(30,10,-250), new THREE.Vector3(-30,20,-280)
  ]},
  {name:"ZoomZoom", trackColor:"green", supportColor:"purple", cartColor:"purple", duration:60000, points:[
    new THREE.Vector3(0,5,0), new THREE.Vector3(-15,25,-30), new THREE.Vector3(20,15,-60),
    new THREE.Vector3(-25,30,-90), new THREE.Vector3(15,10,-120),
    new THREE.Vector3(0,20,-150), new THREE.Vector3(30,25,-180), new THREE.Vector3(-35,15,-210),
    new THREE.Vector3(25,10,-240), new THREE.Vector3(0,15,-270)
  ]},
  {name:"Speedy Spin", trackColor:"yellow", supportColor:"orange", cartColor:"orange", duration:65000, points:[
    new THREE.Vector3(0,5,0),
    new THREE.Vector3(10,15,-15),
    new THREE.Vector3(-10,25,-30),
    new THREE.Vector3(15,10,-45),
    new THREE.Vector3(-15,20,-60),
    new THREE.Vector3(20,5,-75),
    new THREE.Vector3(-20,25,-90),
    new THREE.Vector3(15,15,-105),
    new THREE.Vector3(0,10,-120),
    new THREE.Vector3(10,20,-135),
    new THREE.Vector3(-10,5,-150),
    new THREE.Vector3(0,15,-165)
  ]},
  {name:"Death", trackColor:"red", supportColor:"black", cartColor:"black", duration:70000, points:[
    new THREE.Vector3(0,5,0),
    new THREE.Vector3(25,50,-20),
    new THREE.Vector3(-40,15,-50),
    new THREE.Vector3(50,35,-80),
    new THREE.Vector3(-60,5,-110),
    new THREE.Vector3(70,45,-140),
    new THREE.Vector3(-80,10,-170),
    new THREE.Vector3(90,30,-200),
    new THREE.Vector3(-100,20,-230),
    new THREE.Vector3(110,40,-260),
    new THREE.Vector3(0,5,-290)
  ]}
];

const homeScreen=document.getElementById("homeScreen");
const endScreen=document.getElementById("endScreen");
const rideAgainBtn=document.getElementById("rideAgain");
const homeBtn=document.getElementById("homeBtn");
let currentCoaster=0;

function initButtons(){
  document.getElementById('coaster0').addEventListener('click', ()=>startRide(0));
  document.getElementById('coaster1').addEventListener('click', ()=>startRide(1));
  document.getElementById('coaster2').addEventListener('click', ()=>startRide(2));
  document.getElementById('coaster3').addEventListener('click', ()=>startRide(3));
  document.getElementById('coaster4').addEventListener('click', ()=>startRide(4));
  rideAgainBtn.addEventListener('click', ()=>startRide(currentCoaster));
  homeBtn.addEventListener('click', goHome);
}

function createSupports(points, color){
  const supportMat = new THREE.MeshStandardMaterial({color: color});
  const supports = new THREE.Group();
  points.forEach(p => {
    const geo = new THREE.CylinderGeometry(0.2,0.2, p.y, 8);
    const mesh = new THREE.Mesh(geo, supportMat);
    mesh.position.set(p.x, p.y/2, p.z);
    supports.add(mesh);
  });
  scene.add(supports);
}

function init(){
  scene=new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  camera=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight,0.1,2000);
  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  const light=new THREE.DirectionalLight(0xffffff,1);
  light.position.set(50,50,50);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x888888));
  const ground=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), new THREE.MeshLambertMaterial({color:0x228B22}));
  ground.rotation.x=-Math.PI/2;
  scene.add(ground);
  const cartGeo=new THREE.BoxGeometry(1,0.5,1.5);
  cart=new THREE.Mesh(cartGeo,new THREE.MeshStandardMaterial({color:"red"}));
  scene.add(cart);
  renderer.domElement.addEventListener('mousedown', e=>{isDragging=true; previousX=e.clientX; previousY=e.clientY;});
  renderer.domElement.addEventListener('mousemove', e=>{if(isDragging){yaw += (e.clientX-previousX)*0.002; pitch += (e.clientY-previousY)*0.002; pitch = Math.max(-Math.PI/4, Math.min(Math.PI/4, pitch)); previousX=e.clientX; previousY=e.clientY;}});
  renderer.domElement.addEventListener('mouseup', ()=>{isDragging=false;});
  renderer.domElement.addEventListener('mouseleave', ()=>{isDragging=false;});
  window.addEventListener("resize", ()=>{camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);});
  initButtons();
}

init();

function startRide(coasterIndex){
  currentCoaster=coasterIndex;
  homeScreen.style.display="none";
  endScreen.style.display="none";
  riding=true;
  progress=0;
  startTime=performance.now();
  const c=coasters[coasterIndex];
  scene.children = scene.children.filter(o=>!o.userData?.track && !o.userData?.endText && o!==cart);
  curve=new THREE.CatmullRomCurve3(c.points, false, "catmullrom", 0.5);
  const railMat=new THREE.MeshStandardMaterial({color:c.trackColor, metalness:0.6, roughness:0.3});
  const railGeo=new THREE.TubeGeometry(curve,600,0.2,8,false);
  const track=new THREE.Mesh(railGeo, railMat);
  track.userData.track=true;
  scene.add(track);
  createSupports(c.points, c.supportColor);
  cart.material.color.set(c.cartColor);
  try { 
    const loader = new THREE.FontLoader(); 
    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) { 
      if(endText) scene.remove(endText); 
      const textGeo = new THREE.TextGeometry('END', { font:font, size:5, height:1 }); 
      const textMat = new THREE.MeshStandardMaterial({color:0xffff00}); 
      endText=new THREE.Mesh(textGeo,textMat); 
      const endPos=curve.getPointAt(1); 
      endText.position.set(endPos.x-2.5, endPos.y+5, endPos.z); 
      endText.userData.endText=true; 
      scene.add(endText); 
    }); 
  } catch(e){ console.warn('Font/TextGeometry load failed, skipping END text'); }
  animate();
}

function goHome(){ homeScreen.style.display="flex"; endScreen.style.display="none"; riding=false; }

function animate(){ 
  if(!riding) return; 
  requestAnimationFrame(animate); 
  const elapsed=performance.now()-startTime; 
  const c=coasters[currentCoaster]; 
  let rawProgress = elapsed/c.duration; 
  if(rawProgress>0.85) rawProgress = 0.85 + (rawProgress-0.85)*0.3; 
  progress=Math.min(rawProgress,1); 
  if(progress>=1){ riding=false; endScreen.style.display="flex"; return; } 
  const pos=curve.getPointAt(progress); 
  const tangent=curve.getTangentAt(progress); 
  cart.position.copy(pos); 
  cart.lookAt(pos.clone().add(tangent)); 
  const camOffset = tangent.clone().multiplyScalar(0.8).add(new THREE.Vector3(0,0.5,0)); 
  camera.position.copy(pos.clone().add(camOffset)); 
  const forward = tangent.clone().normalize(); 
  forward.applyAxisAngle(new THREE.Vector3(0,1,0), yaw); 
  const lookTarget = camera.position.clone().add(forward); 
  lookTarget.y += pitch; 
  camera.lookAt(lookTarget); 
  renderer.render(scene,camera); 
}
</script>
</body>
</html>
